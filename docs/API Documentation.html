

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>API Documentation &mdash; geometric  documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=e59714d7" />

  
      <script src="_static/jquery.js?v=5d32c60e"></script>
      <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="_static/documentation_options.js?v=5929fcd5"></script>
      <script src="_static/doctools.js?v=9a2dae69"></script>
      <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
      <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
      <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="Representation" href="Representation.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            geometric
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Representation.html">Representation</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">API Documentation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#vectors-and-points">Vectors and Points</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#geometric.norm"><code class="docutils literal notranslate"><span class="pre">norm()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#geometric.is_zero_vector"><code class="docutils literal notranslate"><span class="pre">is_zero_vector()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#geometric.is_on_axis"><code class="docutils literal notranslate"><span class="pre">is_on_axis()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#geometric.middle_point"><code class="docutils literal notranslate"><span class="pre">middle_point()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#geometric.average_point"><code class="docutils literal notranslate"><span class="pre">average_point()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#geometric.distance_between_points"><code class="docutils literal notranslate"><span class="pre">distance_between_points()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#geometric.angle_between_vectors"><code class="docutils literal notranslate"><span class="pre">angle_between_vectors()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#geometric.orthogonal_vector"><code class="docutils literal notranslate"><span class="pre">orthogonal_vector()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#geometric.vector_rotation"><code class="docutils literal notranslate"><span class="pre">vector_rotation()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#lines">Lines</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#geometric.line_from_point_vector"><code class="docutils literal notranslate"><span class="pre">line_from_point_vector()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#geometric.line_from_two_points"><code class="docutils literal notranslate"><span class="pre">line_from_two_points()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#geometric.random_point_on_line"><code class="docutils literal notranslate"><span class="pre">random_point_on_line()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#geometric.is_point_on_line"><code class="docutils literal notranslate"><span class="pre">is_point_on_line()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#planes">Planes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#geometric.plane_from_three_points"><code class="docutils literal notranslate"><span class="pre">plane_from_three_points()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#geometric.plane_from_point_vector"><code class="docutils literal notranslate"><span class="pre">plane_from_point_vector()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#geometric.random_point_on_plane"><code class="docutils literal notranslate"><span class="pre">random_point_on_plane()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#geometric.is_point_on_plane"><code class="docutils literal notranslate"><span class="pre">is_point_on_plane()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#geometric.is_line_on_plane"><code class="docutils literal notranslate"><span class="pre">is_line_on_plane()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#bisector">Bisector</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#geometric.perpendicular_bisector"><code class="docutils literal notranslate"><span class="pre">perpendicular_bisector()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#geometric.angle_bisector_line_from_two_lines"><code class="docutils literal notranslate"><span class="pre">angle_bisector_line_from_two_lines()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#geometric.angle_bisector_plane_from_two_lines"><code class="docutils literal notranslate"><span class="pre">angle_bisector_plane_from_two_lines()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#geometric.angle_bisector_plane_from_two_planes"><code class="docutils literal notranslate"><span class="pre">angle_bisector_plane_from_two_planes()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#projection-and-distance">Projection and Distance</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#geometric.nearest_point"><code class="docutils literal notranslate"><span class="pre">nearest_point()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#geometric.nearest_distance"><code class="docutils literal notranslate"><span class="pre">nearest_distance()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#geometric.vector_projection"><code class="docutils literal notranslate"><span class="pre">vector_projection()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#geometric.project_vector_on_plane"><code class="docutils literal notranslate"><span class="pre">project_vector_on_plane()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#geometric.project_point_on_line"><code class="docutils literal notranslate"><span class="pre">project_point_on_line()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#geometric.project_point_on_plane"><code class="docutils literal notranslate"><span class="pre">project_point_on_plane()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#geometric.project_line_on_plane"><code class="docutils literal notranslate"><span class="pre">project_line_on_plane()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#geometric.distance_point_to_line"><code class="docutils literal notranslate"><span class="pre">distance_point_to_line()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#geometric.distance_point_to_plane"><code class="docutils literal notranslate"><span class="pre">distance_point_to_plane()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#intersection">Intersection</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#geometric.intersection_between_lines"><code class="docutils literal notranslate"><span class="pre">intersection_between_lines()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#geometric.intersection_between_line_segments"><code class="docutils literal notranslate"><span class="pre">intersection_between_line_segments()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#geometric.intersection_between_line_and_circle"><code class="docutils literal notranslate"><span class="pre">intersection_between_line_and_circle()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#geometric.line_from_planes"><code class="docutils literal notranslate"><span class="pre">line_from_planes()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#geometric.point_from_plane_and_line"><code class="docutils literal notranslate"><span class="pre">point_from_plane_and_line()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#geometric.point_from_three_planes"><code class="docutils literal notranslate"><span class="pre">point_from_three_planes()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#circle">Circle</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#geometric.circle_from_three_points"><code class="docutils literal notranslate"><span class="pre">circle_from_three_points()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#geometric.circle_from_center_and_points"><code class="docutils literal notranslate"><span class="pre">circle_from_center_and_points()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#geometric.circle_from_center_and_radius"><code class="docutils literal notranslate"><span class="pre">circle_from_center_and_radius()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#geometric.generate_points_on_circle"><code class="docutils literal notranslate"><span class="pre">generate_points_on_circle()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#geometric.circle_coordinate_transform"><code class="docutils literal notranslate"><span class="pre">circle_coordinate_transform()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#arc">Arc</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#geometric.arc_from_center_and_endpoints"><code class="docutils literal notranslate"><span class="pre">arc_from_center_and_endpoints()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#geometric.arc_from_three_points"><code class="docutils literal notranslate"><span class="pre">arc_from_three_points()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#geometric.generate_points_on_arc"><code class="docutils literal notranslate"><span class="pre">generate_points_on_arc()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#geometric.is_point_on_arc"><code class="docutils literal notranslate"><span class="pre">is_point_on_arc()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#sphere">Sphere</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#geometric.distance_between_points_on_sphere"><code class="docutils literal notranslate"><span class="pre">distance_between_points_on_sphere()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#geometric.random_point_on_sphere"><code class="docutils literal notranslate"><span class="pre">random_point_on_sphere()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#geometric.spherical_cap_volume"><code class="docutils literal notranslate"><span class="pre">spherical_cap_volume()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#geometric.overlap_volume_between_spheres"><code class="docutils literal notranslate"><span class="pre">overlap_volume_between_spheres()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#parameters-from-noisy-data">Parameters from Noisy Data</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#geometric.line_from_noisy_data"><code class="docutils literal notranslate"><span class="pre">line_from_noisy_data()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#geometric.plane_from_noisy_data"><code class="docutils literal notranslate"><span class="pre">plane_from_noisy_data()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#geometric.circle_from_noisy_data"><code class="docutils literal notranslate"><span class="pre">circle_from_noisy_data()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#relation-between-point-and-shape">Relation between Point and Shape</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#geometric.point_triangle_relation"><code class="docutils literal notranslate"><span class="pre">point_triangle_relation()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#geometric.point_cylinder_relation"><code class="docutils literal notranslate"><span class="pre">point_cylinder_relation()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#geometric.point_sphere_relation"><code class="docutils literal notranslate"><span class="pre">point_sphere_relation()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#geometric.point_circle_relation"><code class="docutils literal notranslate"><span class="pre">point_circle_relation()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#transform-between-coordinates">Transform between Coordinates</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#geometric.cartesian_to_spherical"><code class="docutils literal notranslate"><span class="pre">cartesian_to_spherical()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#geometric.spherical_to_cartesian"><code class="docutils literal notranslate"><span class="pre">spherical_to_cartesian()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#pose">Pose</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#geometric.Pose"><code class="docutils literal notranslate"><span class="pre">Pose</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#geometric.Pose.matrix"><code class="docutils literal notranslate"><span class="pre">Pose.matrix</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#geometric.Pose.translation"><code class="docutils literal notranslate"><span class="pre">Pose.translation</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#geometric.Pose.rotation"><code class="docutils literal notranslate"><span class="pre">Pose.rotation</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#geometric.Pose.inv"><code class="docutils literal notranslate"><span class="pre">Pose.inv</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#geometric.Pose.chain"><code class="docutils literal notranslate"><span class="pre">Pose.chain()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#geometric.Pose.diff"><code class="docutils literal notranslate"><span class="pre">Pose.diff()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#geometric.Pose.distance"><code class="docutils literal notranslate"><span class="pre">Pose.distance()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#geometric.Pose.from_matrix"><code class="docutils literal notranslate"><span class="pre">Pose.from_matrix()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#geometric.Pose.from_ros_geometry_pose"><code class="docutils literal notranslate"><span class="pre">Pose.from_ros_geometry_pose()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#geometric.Pose.from_ros_geometry_pose_stamped"><code class="docutils literal notranslate"><span class="pre">Pose.from_ros_geometry_pose_stamped()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#geometric.Pose.get_axis_angle"><code class="docutils literal notranslate"><span class="pre">Pose.get_axis_angle()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#geometric.Pose.get_euler"><code class="docutils literal notranslate"><span class="pre">Pose.get_euler()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#geometric.Pose.get_quaternion"><code class="docutils literal notranslate"><span class="pre">Pose.get_quaternion()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#geometric.Pose.get_rotvec"><code class="docutils literal notranslate"><span class="pre">Pose.get_rotvec()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#geometric.Pose.identity"><code class="docutils literal notranslate"><span class="pre">Pose.identity()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#geometric.Pose.interpolate"><code class="docutils literal notranslate"><span class="pre">Pose.interpolate()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#geometric.Pose.random_pose"><code class="docutils literal notranslate"><span class="pre">Pose.random_pose()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#geometric.Pose.set_rotation_from_axis_angle"><code class="docutils literal notranslate"><span class="pre">Pose.set_rotation_from_axis_angle()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#geometric.Pose.set_rotation_from_euler"><code class="docutils literal notranslate"><span class="pre">Pose.set_rotation_from_euler()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#geometric.Pose.set_rotation_from_matrix"><code class="docutils literal notranslate"><span class="pre">Pose.set_rotation_from_matrix()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#geometric.Pose.set_rotation_from_quaternion"><code class="docutils literal notranslate"><span class="pre">Pose.set_rotation_from_quaternion()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#geometric.Pose.set_rotation_from_rotvec"><code class="docutils literal notranslate"><span class="pre">Pose.set_rotation_from_rotvec()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#geometric.Pose.set_rotation_from_vector"><code class="docutils literal notranslate"><span class="pre">Pose.set_rotation_from_vector()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#geometric.Pose.set_translation"><code class="docutils literal notranslate"><span class="pre">Pose.set_translation()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#geometric.Pose.transform_point"><code class="docutils literal notranslate"><span class="pre">Pose.transform_point()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#geometric.Pose.transform_points"><code class="docutils literal notranslate"><span class="pre">Pose.transform_points()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">geometric</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">API Documentation</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/API Documentation.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="api-documentation">
<h1>API Documentation<a class="headerlink" href="#api-documentation" title="Link to this heading"></a></h1>
<section id="vectors-and-points">
<h2>Vectors and Points<a class="headerlink" href="#vectors-and-points" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="geometric.norm">
<span class="sig-prename descclassname"><span class="pre">geometric.</span></span><span class="sig-name descname"><span class="pre">norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#geometric.norm" title="Link to this definition"></a></dt>
<dd><p>Calculate the norm of a given vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>vector</strong> (<em>list</em><em> or </em><em>array-like</em>) – The vector to compute the norm</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The norm of the vector</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geometric.is_zero_vector">
<span class="sig-prename descclassname"><span class="pre">geometric.</span></span><span class="sig-name descname"><span class="pre">is_zero_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#geometric.is_zero_vector" title="Link to this definition"></a></dt>
<dd><p>Check if a given vector is a zero vector within a specified tolerance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>vector</strong> (<em>list</em><em> or </em><em>array-like</em>) – The vector to check</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>True if the vector is a zero vector, False otherwise</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geometric.is_on_axis">
<span class="sig-prename descclassname"><span class="pre">geometric.</span></span><span class="sig-name descname"><span class="pre">is_on_axis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#geometric.is_on_axis" title="Link to this definition"></a></dt>
<dd><p>Check if a given vector lies on one of the coordinate axes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>vector</strong> (<em>list</em><em> or </em><em>array-like</em>) – The vector to check</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p>A tuple containing</p>
<ul class="simple">
<li><p>bool: True if the vector lies on one of the coordinate axes, False otherwise.</p></li>
<li><p>int: The index of the axis if the vector lies on an axis, -1 otherwise.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>AssertionError</strong> – If the input vector is a zero vector</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>0 for X, 1 for Y and 2 for Z</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geometric.middle_point">
<span class="sig-prename descclassname"><span class="pre">geometric.</span></span><span class="sig-name descname"><span class="pre">middle_point</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#geometric.middle_point" title="Link to this definition"></a></dt>
<dd><p>Calculate the middle point between two points in the same dimensional space.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>p1</strong> (<em>list</em><em> or </em><em>array-like</em>) – The first point.</p></li>
<li><p><strong>p2</strong> (<em>list</em><em> or </em><em>array-like</em>) – The second point.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The coordinates of the middle point.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.ndarray</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>AssertionError</strong> – If the two points do not have the same dimensions.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geometric.average_point">
<span class="sig-prename descclassname"><span class="pre">geometric.</span></span><span class="sig-name descname"><span class="pre">average_point</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">p</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#geometric.average_point" title="Link to this definition"></a></dt>
<dd><p>Calculate the weighted average point of given points.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>p</strong> (<em>array-like</em>) – A variable number of points</p></li>
<li><p><strong>kwargs</strong> (<em>dict</em>) – <p>Optional keyword arguments</p>
<ul>
<li><p>weights (array-like, optional): The weights associated with each point. Default is None</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The coordinates of the average point.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.ndarray</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – If the dimensions of the input points or weights do not match,
    or if weights contain any invalid values.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geometric.distance_between_points">
<span class="sig-prename descclassname"><span class="pre">geometric.</span></span><span class="sig-name descname"><span class="pre">distance_between_points</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#geometric.distance_between_points" title="Link to this definition"></a></dt>
<dd><p>Calculate the Euclidean distance between two points.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>p1</strong> (<em>list</em><em> or </em><em>array-like</em>) – The first point</p></li>
<li><p><strong>p2</strong> (<em>list</em><em> or </em><em>array-like</em>) – The second point</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The Euclidean distance between the two points</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>AssertionError</strong> – If the two points do not have the same dimensions</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geometric.angle_between_vectors">
<span class="sig-prename descclassname"><span class="pre">geometric.</span></span><span class="sig-name descname"><span class="pre">angle_between_vectors</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">degrees</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#geometric.angle_between_vectors" title="Link to this definition"></a></dt>
<dd><p>Calculate the angle between two vectors in radians or degrees.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>v1</strong> (<em>list</em><em> or </em><em>array-like</em>) – First vector</p></li>
<li><p><strong>v2</strong> (<em>list</em><em> or </em><em>array-like</em>) – Second vector</p></li>
<li><p><strong>degrees</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, return the angle in degrees. Default is False (radians).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Angle between v1 and v2</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>AssertionError</strong> – If the dimensions of v1 and v2 are not equal,
    or if both vectors are zero vectors.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Return value will be in range [0, <span class="math notranslate nohighlight">\(\pi\)</span>]</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geometric.orthogonal_vector">
<span class="sig-prename descclassname"><span class="pre">geometric.</span></span><span class="sig-name descname"><span class="pre">orthogonal_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#geometric.orthogonal_vector" title="Link to this definition"></a></dt>
<dd><p>Return a unit vector (randomly, for n &gt;= 3) that is orthogonal to the input vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>v</strong> (<em>list</em><em> or </em><em>array-like</em>) – Input vector</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Unit vector that is orthogonal to the input vector</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.ndarray</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>AssertionError</strong> – If input vector is 1D</p></li>
<li><p><strong>AssertionError</strong> – If input is zero vector</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geometric.vector_rotation">
<span class="sig-prename descclassname"><span class="pre">geometric.</span></span><span class="sig-name descname"><span class="pre">vector_rotation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#geometric.vector_rotation" title="Link to this definition"></a></dt>
<dd><p>Rotate vector in 2D counter-clockwise.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>v</strong> (<em>list</em><em> or </em><em>array-like</em>) – Vector in 2D.</p></li>
<li><p><strong>theta</strong> (<em>float</em>) – Angle to rotate, with unit radian</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Rotated vector</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.array</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>AssertionError</strong> – If input vector is not in 2D</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="lines">
<h2>Lines<a class="headerlink" href="#lines" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="geometric.line_from_point_vector">
<span class="sig-prename descclassname"><span class="pre">geometric.</span></span><span class="sig-name descname"><span class="pre">line_from_point_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#geometric.line_from_point_vector" title="Link to this definition"></a></dt>
<dd><p>Generate the equation of a line in 2D or 3D space given a point on the line and its direction vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> (<em>list</em><em> or </em><em>array-like</em>) – A point on the line</p></li>
<li><p><strong>vector</strong> (<em>list</em><em> or </em><em>array-like</em>) – The direction vector of the line</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><dl class="simple">
<dt>2D</dt><dd><ul>
<li><p>list: The coefficients of the line equation, <span class="math notranslate nohighlight">\(ax + by + c = 0\)</span></p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>3D</dt><dd><ul>
<li><p>list: The point which on the line</p></li>
<li><p>list: Normalized direction vector</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>AssertionError</strong> – If the dimensions of the point and vector do not match the expected dimensions (2 or 3).</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geometric.line_from_two_points">
<span class="sig-prename descclassname"><span class="pre">geometric.</span></span><span class="sig-name descname"><span class="pre">line_from_two_points</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#geometric.line_from_two_points" title="Link to this definition"></a></dt>
<dd><p>Generate the equation of a line in 2D or 3D space passing through two given points.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>p1</strong> (<em>list</em><em> or </em><em>array-like</em>) – Coordinates of the first point</p></li>
<li><p><strong>p2</strong> (<em>list</em><em> or </em><em>array-like</em>) – Coordinates of the second point</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><dl class="simple">
<dt>2D</dt><dd><ul>
<li><p>list: The coefficients of the line equation, <span class="math notranslate nohighlight">\(ax + by + c = 0\)</span></p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>3D</dt><dd><ul>
<li><p>list: The point which on the line</p></li>
<li><p>list: Normalized direction vector</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>AssertionError</strong> – If the dimensions of the points do not match the expected dimensions (2D or 3D).</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geometric.random_point_on_line">
<span class="sig-prename descclassname"><span class="pre">geometric.</span></span><span class="sig-name descname"><span class="pre">random_point_on_line</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">line</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#geometric.random_point_on_line" title="Link to this definition"></a></dt>
<dd><p>Generate a random point on a line in 2D or 3D space.</p>
<p>The function accepts two formats for the input <cite>line</cite>:</p>
<ol class="arabic simple">
<li><p>2D line
A list or array-like of three coefficients [a, b, c], representing the line equation <span class="math notranslate nohighlight">\(ax + by + c = 0\)</span>.</p></li>
<li><p>3D line: A list or array-like of two elements:</p>
<ul class="simple">
<li><p><cite>line[0]</cite>: A 3D point on the line.</p></li>
<li><p><cite>line[1]</cite>: A normalized direction vector of the line.</p></li>
</ul>
</li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>line</strong> (<em>list</em><em> or </em><em>array-like</em>) – Representation of the line, either 2D ([a, b, c]) or 3D ([point, vector]).</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Coordinates of a random point on the line.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.ndarray</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>AssertionError</strong> – If the dimensions of the line do not match the expected dimensions (2D or 3D).</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geometric.is_point_on_line">
<span class="sig-prename descclassname"><span class="pre">geometric.</span></span><span class="sig-name descname"><span class="pre">is_point_on_line</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">line</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#geometric.is_point_on_line" title="Link to this definition"></a></dt>
<dd><p>Check if a point lies on a given line in 2D or 3D space.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> (<em>list</em><em> or </em><em>array-like</em>) – Coordinates of the point to be checked.</p></li>
<li><p><strong>line</strong> (<em>list</em><em> or </em><em>array-like</em>) – <p>Representation of the line:</p>
<ol class="arabic simple">
<li><p>2D: the coefficients of the line equation, <span class="math notranslate nohighlight">\(ax + by + c = 0\)</span></p></li>
<li><p>3D: <code class="docutils literal notranslate"><span class="pre">[[x1,</span> <span class="pre">y1,</span> <span class="pre">z1],</span> <span class="pre">[vx,</span> <span class="pre">vy,</span> <span class="pre">vz]]</span></code> where <code class="docutils literal notranslate"><span class="pre">[x1,</span> <span class="pre">y1,</span> <span class="pre">z1]</span></code> is a point on the line
and <code class="docutils literal notranslate"><span class="pre">[vx,</span> <span class="pre">vy,</span> <span class="pre">vz]</span></code> is the direction vector of the line</p></li>
</ol>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>True if the point lies on the line, False otherwise.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>AssertionError</strong> – If the dimensions of the point and line do not match the expected dimensions</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="planes">
<h2>Planes<a class="headerlink" href="#planes" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="geometric.plane_from_three_points">
<span class="sig-prename descclassname"><span class="pre">geometric.</span></span><span class="sig-name descname"><span class="pre">plane_from_three_points</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p3</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#geometric.plane_from_three_points" title="Link to this definition"></a></dt>
<dd><p>Calculate the plane equation from three points in 3D space.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>p1</strong> (<em>list</em><em> or </em><em>array-like</em>) – Coordinates of the first point</p></li>
<li><p><strong>p2</strong> (<em>list</em><em> or </em><em>array-like</em>) – Coordinates of the second point</p></li>
<li><p><strong>p3</strong> (<em>list</em><em> or </em><em>array-like</em>) – Coordinates of the third point</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The coefficients of the plane equation in the form <span class="math notranslate nohighlight">\(ax + by + cz + d = 0\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>AssertionError</strong> – If the dimensions of the points are not equal to 3,
    or if the points are collinear.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geometric.plane_from_point_vector">
<span class="sig-prename descclassname"><span class="pre">geometric.</span></span><span class="sig-name descname"><span class="pre">plane_from_point_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#geometric.plane_from_point_vector" title="Link to this definition"></a></dt>
<dd><p>Generate the plane equation in 3D space given a point on the plane and its normal vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> (<em>list</em><em> or </em><em>array-like</em>) – A point on the plane</p></li>
<li><p><strong>vector</strong> (<em>list</em><em> or </em><em>array-like</em>) – The normal vector to the plane</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The coefficients of the plane equation in the form <span class="math notranslate nohighlight">\(ax + by + cz + d = 0\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>AssertionError</strong> – If the dimensions of the point and vector are not equal to 3.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geometric.random_point_on_plane">
<span class="sig-prename descclassname"><span class="pre">geometric.</span></span><span class="sig-name descname"><span class="pre">random_point_on_plane</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">plane</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#geometric.random_point_on_plane" title="Link to this definition"></a></dt>
<dd><p>Generate a random point on a plane in 3D space.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>plane</strong> (<em>list</em><em> or </em><em>array-like</em>) – The coefficients of the plane equation in the form <span class="math notranslate nohighlight">\(ax + by + cz + d = 0\)</span></p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Coordinates of a random point on the plane</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.ndarray</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>AssertionError</strong> – If the input plane is invalid</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geometric.is_point_on_plane">
<span class="sig-prename descclassname"><span class="pre">geometric.</span></span><span class="sig-name descname"><span class="pre">is_point_on_plane</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plane</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#geometric.is_point_on_plane" title="Link to this definition"></a></dt>
<dd><p>Check if a point lies on a given plane in 3D space.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> (<em>list</em><em> or </em><em>array-like</em>) – coordinates of the point to be checked</p></li>
<li><p><strong>plane</strong> (<em>list</em><em> or </em><em>array-like</em>) – representation of the plane as [a, b, c, d]
where the plane equation is ax + by + cz + d = 0.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>True if the point lies on the plane, False otherwise</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>on_plane (bool)</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>AssertionError</strong> – if the dimensions of the plane and point do not match the expected dimensions</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geometric.is_line_on_plane">
<span class="sig-prename descclassname"><span class="pre">geometric.</span></span><span class="sig-name descname"><span class="pre">is_line_on_plane</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">line</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plane</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#geometric.is_line_on_plane" title="Link to this definition"></a></dt>
<dd><p>Check if a line lies on a given plane in 3D space.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>line</strong> (<em>list</em><em> or </em><em>array-like</em>) – representation of the line as <code class="docutils literal notranslate"><span class="pre">[[x1,</span> <span class="pre">y1,</span> <span class="pre">z1],</span> <span class="pre">[vx,</span> <span class="pre">vy,</span> <span class="pre">vz]]</span></code>
where <code class="docutils literal notranslate"><span class="pre">[x1,</span> <span class="pre">y1,</span> <span class="pre">z1]</span></code> is a point on the line and
<code class="docutils literal notranslate"><span class="pre">[vx,</span> <span class="pre">vy,</span> <span class="pre">vz]</span></code> is the direction vector of the line</p></li>
<li><p><strong>plane</strong> (<em>array-like</em>) – representation of the plane as [a, b, c, d]
where the plane equation is <span class="math notranslate nohighlight">\(ax + by + cz + d = 0\)</span></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>True if the line lies on the plane, False otherwise</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>on_plane (bool)</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>AssertionError</strong> – if the dimensions of the line and plane do not match the expected dimensions.</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="bisector">
<h2>Bisector<a class="headerlink" href="#bisector" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="geometric.perpendicular_bisector">
<span class="sig-prename descclassname"><span class="pre">geometric.</span></span><span class="sig-name descname"><span class="pre">perpendicular_bisector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#geometric.perpendicular_bisector" title="Link to this definition"></a></dt>
<dd><p>Calculate the perpendicular bisector of a line segment in 2D or 3D space.</p>
<p>The function determines the perpendicular bisector:</p>
<ul class="simple">
<li><p>In <strong>2D</strong>, it returns the line coefficients [a, b, c] of the equation: <span class="math notranslate nohighlight">\(ax + by + c = 0\)</span>.</p></li>
<li><p>In <strong>3D</strong>, it returns the plane coefficients [a, b, c, d] of the equation: <span class="math notranslate nohighlight">\(ax + by + cz + d = 0\)</span>.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>p1</strong> (<em>list</em><em> or </em><em>array-like</em>) – Coordinates of the first endpoint of the line segment.</p></li>
<li><p><strong>p2</strong> (<em>list</em><em> or </em><em>array-like</em>) – Coordinates of the second endpoint of the line segment.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Coefficients of the perpendicular bisector line (2D) or plane (3D).</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>AssertionError</strong> – If the dimensions of the points do not match the expected dimensions (2D or 3D).</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geometric.angle_bisector_line_from_two_lines">
<span class="sig-prename descclassname"><span class="pre">geometric.</span></span><span class="sig-name descname"><span class="pre">angle_bisector_line_from_two_lines</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">line_1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">line_2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#geometric.angle_bisector_line_from_two_lines" title="Link to this definition"></a></dt>
<dd><p>Calculate the two angle bisector lines from two input lines in 2D or 3D space.</p>
<ul class="simple">
<li><p>In 2D: Each line is represented by coefficients [a, b, c] of the line equation <span class="math notranslate nohighlight">\(ax + by + c = 0\)</span>.</p></li>
<li><p>In 3D: Each line is represented by a list [point, direction_vector].</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>line_1</strong> (<em>list</em><em> or </em><em>array-like</em>) – First line, either 2D coefficients or 3D [point, vector].</p></li>
<li><p><strong>line_2</strong> (<em>list</em><em> or </em><em>array-like</em>) – Second line, same format as <cite>line_1</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p>A pair of bisector lines.</p>
<blockquote>
<div><ul class="simple">
<li><p>In 2D, each is a list of coefficients [a, b, c].</p></li>
<li><p>In 3D, each is a list [point, direction_vector].</p></li>
</ul>
</div></blockquote>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>AssertionError</strong> – If the input lines are invalid or do not intersect (e.g., parallel lines).</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geometric.angle_bisector_plane_from_two_lines">
<span class="sig-prename descclassname"><span class="pre">geometric.</span></span><span class="sig-name descname"><span class="pre">angle_bisector_plane_from_two_lines</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">line_1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">line_2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#geometric.angle_bisector_plane_from_two_lines" title="Link to this definition"></a></dt>
<dd><p>Compute the two angle bisector planes formed by two intersecting 3D lines.</p>
<p>Each line is defined by [point, direction_vector].</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>line_1</strong> (<em>list</em>) – First 3D line as [point, direction_vector].</p></li>
<li><p><strong>line_2</strong> (<em>list</em>) – Second 3D line as [point, direction_vector].</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>A pair of planes, each represented by coefficients [a, b, c, d] of the plane equation</dt><dd><p><span class="math notranslate nohighlight">\(ax + by + cz + d = 0\)</span>.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>AssertionError</strong> – If input lines are invalid or do not intersect.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geometric.angle_bisector_plane_from_two_planes">
<span class="sig-prename descclassname"><span class="pre">geometric.</span></span><span class="sig-name descname"><span class="pre">angle_bisector_plane_from_two_planes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">plane_1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plane_2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#geometric.angle_bisector_plane_from_two_planes" title="Link to this definition"></a></dt>
<dd><p>Compute the two angle bisector planes formed by the intersection of two planes.</p>
<p>The result is two new planes whose normal vectors bisect the angle between the original planes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>plane_1</strong> (<em>list</em>) – First plane coefficients [a, b, c, d] of the equation <span class="math notranslate nohighlight">\(ax + by + cz + d = 0\)</span>.</p></li>
<li><p><strong>plane_2</strong> (<em>list</em>) – Second plane coefficients [a, b, c, d].</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A pair of normalized plane coefficients [a, b, c, d].</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>AssertionError</strong> – If the input planes are invalid or do not intersect along a line.</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="projection-and-distance">
<h2>Projection and Distance<a class="headerlink" href="#projection-and-distance" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="geometric.nearest_point">
<span class="sig-prename descclassname"><span class="pre">geometric.</span></span><span class="sig-name descname"><span class="pre">nearest_point</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vector</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_point</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#geometric.nearest_point" title="Link to this definition"></a></dt>
<dd><p>Given a point and a vector, as well as another point, return the
nearest point on the line passing through the point in the direction
of the vector and the other point.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> (<em>list</em><em> or </em><em>array-like</em>) – Coordinates of the point through which the line passes</p></li>
<li><p><strong>vector</strong> (<em>list</em><em> or </em><em>array-like</em>) – Direction vector of the line</p></li>
<li><p><strong>target_point</strong> (<em>list</em><em> or </em><em>array-like</em>) – Coordinates of the target point</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>the nearest point on the line</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.array</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference external" href="#geometric.project_point_on_line">project_point_on_line</a></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geometric.nearest_distance">
<span class="sig-prename descclassname"><span class="pre">geometric.</span></span><span class="sig-name descname"><span class="pre">nearest_distance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vector</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_point</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#geometric.nearest_distance" title="Link to this definition"></a></dt>
<dd><p>Given a point and a vector, as well as another point, return the
shortest distance between the line passing through the point in the
direction of the vector and the other point.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> (<em>list</em><em> or </em><em>array-like</em>) – Coordinates of the point through which the line passes</p></li>
<li><p><strong>vector</strong> (<em>list</em><em> or </em><em>array-like</em>) – Direction vector of the line</p></li>
<li><p><strong>target_point</strong> (<em>list</em><em> or </em><em>array-like</em>) – Coordinates of the target point</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The shortest distance between the line and the target point</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geometric.vector_projection">
<span class="sig-prename descclassname"><span class="pre">geometric.</span></span><span class="sig-name descname"><span class="pre">vector_projection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#geometric.vector_projection" title="Link to this definition"></a></dt>
<dd><p>Project a vector, v1, onto another vector, v2.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>v1</strong> (<em>list</em><em> or </em><em>array-like</em>) – Vector to be projected</p></li>
<li><p><strong>v2</strong> (<em>list</em><em> or </em><em>array-like</em>) – Vector onto which v1 is projected</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Projection of v1 onto v2</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.array</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>AssertionError</strong> – If the dimensions of v1 and v2 are not equal,
    or if v2 is a zero vector.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geometric.project_vector_on_plane">
<span class="sig-prename descclassname"><span class="pre">geometric.</span></span><span class="sig-name descname"><span class="pre">project_vector_on_plane</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normal</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#geometric.project_vector_on_plane" title="Link to this definition"></a></dt>
<dd><p>Project a vector, v, onto a plane represented by its normal vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>v</strong> (<em>list</em><em> or </em><em>array-like</em>) – Vector to be projected.</p></li>
<li><p><strong>normal</strong> (<em>list</em><em> or </em><em>array-like</em>) – Normal vector of the plane</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Projection of v onto the plane</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.array</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>AssertionError</strong> – If the dimensions of v and normal are not equal, or if they are not in 3D space</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geometric.project_point_on_line">
<span class="sig-prename descclassname"><span class="pre">geometric.</span></span><span class="sig-name descname"><span class="pre">project_point_on_line</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">line</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#geometric.project_point_on_line" title="Link to this definition"></a></dt>
<dd><p>Project a point onto a line in 2D or 3D space based on inputs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>p</strong> (<em>list</em><em> or </em><em>array-like</em>) – The point to be projected</p></li>
<li><p><strong>line</strong> (<em>list</em><em> or </em><em>array-like</em>) – <p>Representation of the line:</p>
<ol class="arabic simple">
<li><p>2D: the coefficients of the line equation, <span class="math notranslate nohighlight">\(ax + by + c = 0\)</span></p></li>
<li><dl class="simple">
<dt>3D: <code class="docutils literal notranslate"><span class="pre">[[x1,</span> <span class="pre">y1,</span> <span class="pre">z1],</span> <span class="pre">[vx,</span> <span class="pre">vy,</span> <span class="pre">vz]]</span></code> where <code class="docutils literal notranslate"><span class="pre">[x1,</span> <span class="pre">y1,</span> <span class="pre">z1]</span></code> is a point on the line</dt><dd><p>and <code class="docutils literal notranslate"><span class="pre">[vx,</span> <span class="pre">vy,</span> <span class="pre">vz]</span></code> is the direction vector of the line</p>
</dd>
</dl>
</li>
</ol>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The projected point on the line.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.array</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>AssertionError</strong> – If the dimensions of <cite>p</cite> and <cite>line</cite> do not match the expected dimensions.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference external" href="#geometric.nearest_point">nearest_point</a></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geometric.project_point_on_plane">
<span class="sig-prename descclassname"><span class="pre">geometric.</span></span><span class="sig-name descname"><span class="pre">project_point_on_plane</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plane</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#geometric.project_point_on_plane" title="Link to this definition"></a></dt>
<dd><p>Project a point onto a given plane in 3D space.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>p</strong> (<em>list</em><em> or </em><em>array-like</em>) – Coordinates of the point to be projected</p></li>
<li><p><strong>plane</strong> (<em>list</em><em> or </em><em>array-like</em>) – Representation of the plane as [a, b, c, d]
where the plane equation is <span class="math notranslate nohighlight">\(ax + by + cz + d = 0\)</span></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Coordinates of the projected point on the plane.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.array</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>AssertionError</strong> – If the dimensions of the point and plane do not match the expected dimensions.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geometric.project_line_on_plane">
<span class="sig-prename descclassname"><span class="pre">geometric.</span></span><span class="sig-name descname"><span class="pre">project_line_on_plane</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">line</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plane</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#geometric.project_line_on_plane" title="Link to this definition"></a></dt>
<dd><p>Project a line onto a given plane in 3D space.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>line</strong> (<em>list</em><em> or </em><em>array-like</em>) – Representation of the line as <code class="docutils literal notranslate"><span class="pre">[[x1,</span> <span class="pre">y1,</span> <span class="pre">z1],</span> <span class="pre">[vx,</span> <span class="pre">vy,</span> <span class="pre">vz]]</span></code>
where <code class="docutils literal notranslate"><span class="pre">[x1,</span> <span class="pre">y1,</span> <span class="pre">z1]</span></code> is a point on the line and
<code class="docutils literal notranslate"><span class="pre">[vx,</span> <span class="pre">vy,</span> <span class="pre">vz]</span></code> is the direction vector of the line</p></li>
<li><p><strong>plane</strong> (<em>list</em><em> or </em><em>array-like</em>) – Representation of the plane as [a, b, c, d]
where the plane equation is <span class="math notranslate nohighlight">\(ax + by + cz + d = 0\)</span></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>a list containing the projected point on the plane and the projected direction vector on the plane.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>AssertionError</strong> – if the dimensions of the line and plane do not match the expected dimensions.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geometric.distance_point_to_line">
<span class="sig-prename descclassname"><span class="pre">geometric.</span></span><span class="sig-name descname"><span class="pre">distance_point_to_line</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">line</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#geometric.distance_point_to_line" title="Link to this definition"></a></dt>
<dd><p>Calculate the distance from a point to a line in 2D space.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>p</strong> (<em>list</em><em> or </em><em>array-like</em>) – A single point <code class="docutils literal notranslate"><span class="pre">[x,</span> <span class="pre">y]</span></code> or multiple points <code class="docutils literal notranslate"><span class="pre">[[x1,</span> <span class="pre">y1],</span> <span class="pre">[x2,</span> <span class="pre">y2],</span> <span class="pre">...]</span></code>.</p></li>
<li><p><strong>line</strong> (<em>list</em><em> or </em><em>array-like</em>) – Coefficients of the line equation ax + by + c = 0</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Distance (if input is a single point) or an array of distances (if multiple points).</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float or np.ndarray</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>AssertionError</strong> – If the dimensions of the point and line do not match the expected dimensions.</p>
</dd>
</dl>
<div class="admonition-todo admonition" id="id1">
<p class="admonition-title">Todo</p>
<p>Should also supports 3D.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geometric.distance_point_to_plane">
<span class="sig-prename descclassname"><span class="pre">geometric.</span></span><span class="sig-name descname"><span class="pre">distance_point_to_plane</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plane</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#geometric.distance_point_to_plane" title="Link to this definition"></a></dt>
<dd><p>Calculate the distance from a point to a plane in 3D space.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>p</strong> (<em>list</em><em> or </em><em>array-like</em>) – A single point <code class="docutils literal notranslate"><span class="pre">[x,</span> <span class="pre">y,</span> <span class="pre">z]</span></code> or multiple points <code class="docutils literal notranslate"><span class="pre">[[x1,</span> <span class="pre">y1,</span> <span class="pre">z1],</span> <span class="pre">[x2,</span> <span class="pre">y2,</span> <span class="pre">z2],</span> <span class="pre">...]</span></code>.</p></li>
<li><p><strong>plane</strong> (<em>list</em><em> or </em><em>array-like</em>) – Representation of the plane as <code class="docutils literal notranslate"><span class="pre">[a,</span> <span class="pre">b,</span> <span class="pre">c,</span> <span class="pre">d]</span></code>
where the plane equation is <span class="math notranslate nohighlight">\(ax + by + cz + d = 0\)</span></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Distance (if input is a single point) or an array of distances (if multiple points).</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float or np.ndarray</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>AssertionError</strong> – If the dimensions of the point and plane do not match the expected dimensions</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="intersection">
<h2>Intersection<a class="headerlink" href="#intersection" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="geometric.intersection_between_lines">
<span class="sig-prename descclassname"><span class="pre">geometric.</span></span><span class="sig-name descname"><span class="pre">intersection_between_lines</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">line_1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">line_2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#geometric.intersection_between_lines" title="Link to this definition"></a></dt>
<dd><p>Find the intersection point between two lines.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>line_1</strong> (<em>list</em><em> or </em><em>array-like</em>) – <p>the first line. Representation of the line:</p>
<ol class="arabic simple">
<li><p>2D: The coefficients of the line equation <span class="math notranslate nohighlight">\(ax + by + c = 0\)</span></p></li>
<li><dl class="simple">
<dt>3D: <code class="docutils literal notranslate"><span class="pre">[[x1,</span> <span class="pre">y1,</span> <span class="pre">z1],</span> <span class="pre">[vx,</span> <span class="pre">vy,</span> <span class="pre">vz]]</span></code> where <code class="docutils literal notranslate"><span class="pre">[x1,</span> <span class="pre">y1,</span> <span class="pre">z1]</span></code> is a point on the line</dt><dd><p>and <code class="docutils literal notranslate"><span class="pre">[vx,</span> <span class="pre">vy,</span> <span class="pre">vz]</span></code> is the direction vector of the line</p>
</dd>
</dl>
</li>
</ol>
</p></li>
<li><p><strong>line_2</strong> (<em>list</em><em> or </em><em>array-like</em>) – the second line, the representation is the same as <cite>line_1</cite></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The intersection point</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.ndarray</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>AssertionError</strong> – If the lines are parallel (in 2D) or do not intersect (in 3D).</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geometric.intersection_between_line_segments">
<span class="sig-prename descclassname"><span class="pre">geometric.</span></span><span class="sig-name descname"><span class="pre">intersection_between_line_segments</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">line_1_points</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">line_2_points</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#geometric.intersection_between_line_segments" title="Link to this definition"></a></dt>
<dd><p>Find the intersection point between two line segments, which are determined by their end-points.
If this two line segments intersect, returns the intersection point; otherwise, an array filled with
<code class="docutils literal notranslate"><span class="pre">NaN</span></code> (not a number) is returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>line_1_points</strong> (<em>list</em><em> or </em><em>array-like</em>) – Two points defining the first line segment</p></li>
<li><p><strong>line_2_points</strong> (<em>list</em><em> or </em><em>array-like</em>) – Two points defining the second line segment</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>The intersection point if the line segments intersect within their bounds.</dt><dd><p>Otherwise, an array of NaNs.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.ndarray</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>AssertionError</strong> – If the input points are not in the correct shape.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geometric.intersection_between_line_and_circle">
<span class="sig-prename descclassname"><span class="pre">geometric.</span></span><span class="sig-name descname"><span class="pre">intersection_between_line_and_circle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">line</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">circle</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#geometric.intersection_between_line_and_circle" title="Link to this definition"></a></dt>
<dd><p>Find intersection points between a line and a circle in 2D or 3D space.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>line</strong> (<em>list</em><em> or </em><em>tuple</em>) – <p>Line parameters depending on dimensionality:</p>
<ul>
<li><p>For 2D: <code class="docutils literal notranslate"><span class="pre">[a,</span> <span class="pre">b,</span> <span class="pre">c]</span></code> Representing the line equation <span class="math notranslate nohighlight">\(ax + by + c = 0\)</span>.</p></li>
<li><p>For 3D: <code class="docutils literal notranslate"><span class="pre">[[x0,</span> <span class="pre">y0,</span> <span class="pre">z0],</span> <span class="pre">[vx,</span> <span class="pre">vy,</span> <span class="pre">vz]]</span></code> representing a point and direction vector respectively.</p></li>
</ul>
</p></li>
<li><p><strong>circle</strong> (<em>tuple</em>) – <ul>
<li><p>center (list or array-like): Coordinates of the circle’s center</p></li>
<li><p>radius (float): Radius of the circle</p></li>
<li><dl class="simple">
<dt>plane (list or array-like): Plane coefficient <code class="docutils literal notranslate"><span class="pre">[a,</span> <span class="pre">b,</span> <span class="pre">c,</span> <span class="pre">d]</span></code> which the circle lies on.</dt><dd><p>For 2D, this term is neglectable.</p>
</dd>
</dl>
</li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>List of intersection point(s)</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>AssertionError</strong> – If the dimensions of center, radius, or plane are incorrect.</p></li>
<li><p><strong>AssertionError</strong> – If got negative radius</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geometric.line_from_planes">
<span class="sig-prename descclassname"><span class="pre">geometric.</span></span><span class="sig-name descname"><span class="pre">line_from_planes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">plane_1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plane_2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#geometric.line_from_planes" title="Link to this definition"></a></dt>
<dd><p>Calculate the intersection line of two planes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>plane_1</strong> (<em>list</em><em> or </em><em>array-like</em>) – Representation of the first plane as <code class="docutils literal notranslate"><span class="pre">[a,</span> <span class="pre">b,</span> <span class="pre">c,</span> <span class="pre">d]</span></code>
where the plane equation is <span class="math notranslate nohighlight">\(ax + by + cz + d = 0\)</span></p></li>
<li><p><strong>plane_2</strong> (<em>list</em><em> or </em><em>array-like</em>) – Same as <cite>plane_1</cite></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>a list containing two elements:</dt><dd><ul class="simple">
<li><p>A point <code class="docutils literal notranslate"><span class="pre">[x,</span> <span class="pre">y,</span> <span class="pre">z]</span></code> on the line of intersection</p></li>
<li><p>A direction vector <code class="docutils literal notranslate"><span class="pre">[i,</span> <span class="pre">j,</span> <span class="pre">k]</span></code> of the line of intersection</p></li>
</ul>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>AssertionError</strong> – if the input planes do not define a unique line (i.e., if they are parallel or coincide).</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geometric.point_from_plane_and_line">
<span class="sig-prename descclassname"><span class="pre">geometric.</span></span><span class="sig-name descname"><span class="pre">point_from_plane_and_line</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">plane</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">line</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#geometric.point_from_plane_and_line" title="Link to this definition"></a></dt>
<dd><p>Calculate the intersection point of a plane and a line in 3D space.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>plane</strong> (<em>list</em><em> or </em><em>array-like</em>) – Representation of the plane as <code class="docutils literal notranslate"><span class="pre">[a,</span> <span class="pre">b,</span> <span class="pre">c,</span> <span class="pre">d]</span></code>
where the plane equation is <span class="math notranslate nohighlight">\(ax + by + cz + d = 0\)</span></p></li>
<li><p><strong>line</strong> (<em>list</em><em> or </em><em>array-like</em>) – Representation of the line as <code class="docutils literal notranslate"><span class="pre">[[x1,</span> <span class="pre">y1,</span> <span class="pre">z1],</span> <span class="pre">[vx,</span> <span class="pre">vy,</span> <span class="pre">vz]]</span></code>
where <code class="docutils literal notranslate"><span class="pre">[x1,</span> <span class="pre">y1,</span> <span class="pre">z1]</span></code> is a point on the line and
<code class="docutils literal notranslate"><span class="pre">[vx,</span> <span class="pre">vy,</span> <span class="pre">vz]</span></code> is the direction vector of the line</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>Coordinates of the intersection point <code class="docutils literal notranslate"><span class="pre">[x,</span> <span class="pre">y,</span> <span class="pre">z]</span></code> if it exists,</dt><dd><p>otherwise a warning message indicating that the line lies on the plane
or is parallel to the plane and an array with 3 <code class="docutils literal notranslate"><span class="pre">NaN</span></code> is returned</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.ndarray</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>AssertionError</strong> – If the dimensions of the plane and line do not match the expected dimensions</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geometric.point_from_three_planes">
<span class="sig-prename descclassname"><span class="pre">geometric.</span></span><span class="sig-name descname"><span class="pre">point_from_three_planes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">plane_1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plane_2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plane_3</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#geometric.point_from_three_planes" title="Link to this definition"></a></dt>
<dd><p>Calculate the intersection point of three planes in 3D space.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>plane_1</strong> (<em>list</em><em> or </em><em>array-like</em>) – Representation of the plane as <code class="docutils literal notranslate"><span class="pre">[a,</span> <span class="pre">b,</span> <span class="pre">c,</span> <span class="pre">d]</span></code>
where the plane equation is <span class="math notranslate nohighlight">\(ax + by + cz + d = 0\)</span></p></li>
<li><p><strong>plane_2</strong> (<em>list</em><em> or </em><em>array-like</em>) – same as <cite>plane_1</cite></p></li>
<li><p><strong>plane_3</strong> (<em>list</em><em> or </em><em>array-like</em>) – same as <cite>plane_1</cite></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Coordinates of the intersection point <code class="docutils literal notranslate"><span class="pre">[x,</span> <span class="pre">y,</span> <span class="pre">z]</span></code></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.ndarry</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>AssertionError</strong> – If the dimensions of the planes do not match the expected dimensions.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>An array with 3 <code class="docutils literal notranslate"><span class="pre">NaN</span></code> is returned if these planes are not intersect at one point</p>
</div>
</dd></dl>

</section>
<section id="circle">
<h2>Circle<a class="headerlink" href="#circle" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="geometric.circle_from_three_points">
<span class="sig-prename descclassname"><span class="pre">geometric.</span></span><span class="sig-name descname"><span class="pre">circle_from_three_points</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p3</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#geometric.circle_from_three_points" title="Link to this definition"></a></dt>
<dd><p>Calculate the circle passing through three points in 2D or 3D space.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>p1</strong> (<em>list</em><em> or </em><em>array-like</em>) – Coordinates of the first point</p></li>
<li><p><strong>p2</strong> (<em>list</em><em> or </em><em>array-like</em>) – Coordinates of the second point</p></li>
<li><p><strong>p3</strong> (<em>list</em><em> or </em><em>array-like</em>) – Coordinates of the third point</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p>A tuple containing:</p>
<blockquote>
<div><ul class="simple">
<li><p>numpy.ndarray: Coordinates of the circle’s center</p></li>
<li><p>float: Radius of the circle</p></li>
<li><p>numpy.ndarray:
Plane coefficient <code class="docutils literal notranslate"><span class="pre">[a,</span> <span class="pre">b,</span> <span class="pre">c,</span> <span class="pre">d]</span></code> which the circle lies in.
For 2D, this term is neglectable and XY plane (<span class="math notranslate nohighlight">\(Z=0\)</span>) is returned</p></li>
</ul>
</div></blockquote>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>AssertionError</strong> – If the points do not lie in the same dimension</p></li>
<li><p><strong>AssertionError</strong> – If the dimension of the point is not 2 nor 3</p></li>
<li><p><strong>AssertionError</strong> – If three points are collinear</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geometric.circle_from_center_and_points">
<span class="sig-prename descclassname"><span class="pre">geometric.</span></span><span class="sig-name descname"><span class="pre">circle_from_center_and_points</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">center</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#geometric.circle_from_center_and_points" title="Link to this definition"></a></dt>
<dd><p>Calculate the circle given its center and two points on its circumference.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>center</strong> (<em>list</em><em> or </em><em>array-like</em>) – Coordinates of the circle’s center</p></li>
<li><p><strong>p1</strong> (<em>list</em><em> or </em><em>array-like</em>) – Coordinates of the first point on the circumference</p></li>
<li><p><strong>p2</strong> (<em>list</em><em> or </em><em>array-like</em>) – Coordinates of the second point on the circumference.
Neglectable for 2D case</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p>A tuple containing</p>
<ul class="simple">
<li><p>numpy.ndarray: Coordinates of the circle’s center</p></li>
<li><p>float: Radius of the circle</p></li>
<li><p>list:
Plane coefficient <code class="docutils literal notranslate"><span class="pre">[a,</span> <span class="pre">b,</span> <span class="pre">c,</span> <span class="pre">d]</span></code> which the circle lies on.
For 2D, this term is neglectable and XY plane (<span class="math notranslate nohighlight">\(Z=0\)</span>) is returned</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>AssertionError</strong> – If the vector from <cite>center</cite> to <cite>p1</cite> is colinear with the vector from <cite>center</cite> to <cite>p2</cite></p></li>
<li><p><strong>AssertionError</strong> – If the points do not lie in the same dimension</p></li>
<li><p><strong>AssertionError</strong> – If the dimension of the point is not 2 nor 3</p></li>
<li><p><strong>AssertionError</strong> – If the distances from the center to p1 and p2 are not equal within a tolerance.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geometric.circle_from_center_and_radius">
<span class="sig-prename descclassname"><span class="pre">geometric.</span></span><span class="sig-name descname"><span class="pre">circle_from_center_and_radius</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">center</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radius</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plane_normal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[0.0,</span> <span class="pre">0.0,</span> <span class="pre">1.0]</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#geometric.circle_from_center_and_radius" title="Link to this definition"></a></dt>
<dd><p>Construct a 2D or 3D circle representation from a center and radius.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>center</strong> (<em>list</em><em> or </em><em>array-like</em>) – The circle center as a 2D (length-2) or 3D (length-3) point.</p></li>
<li><p><strong>radius</strong> (<em>float</em>) – The radius of the circle. Must be positive.</p></li>
<li><p><strong>plane_normal</strong> (<em>list</em><em> or </em><em>array-like</em><em>, </em><em>optional</em>) – A 3D normal vector defining the plane
in which the circle lies. Required only for 3D cases. Defaults to <code class="docutils literal notranslate"><span class="pre">[0.0,</span> <span class="pre">0.0,</span> <span class="pre">1.0]</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p>A tuple containing</p>
<ul class="simple">
<li><p>numpy.ndarray: Coordinates of the circle’s center</p></li>
<li><p>float: Radius of the circle</p></li>
<li><p>list:
Plane coefficient <code class="docutils literal notranslate"><span class="pre">[a,</span> <span class="pre">b,</span> <span class="pre">c,</span> <span class="pre">d]</span></code> which the circle lies on.
For 2D, this term is neglectable and XY plane (<span class="math notranslate nohighlight">\(Z=0\)</span>) is returned</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>AssertionError</strong> – If <cite>radius</cite> is non-positive.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>center</cite> length is neither 2 nor 3</p></li>
<li><p><strong>AssertionError</strong> – If <cite>plane_normal</cite> is invalid in 3D case.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geometric.generate_points_on_circle">
<span class="sig-prename descclassname"><span class="pre">geometric.</span></span><span class="sig-name descname"><span class="pre">generate_points_on_circle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">center</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radius</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plane</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#geometric.generate_points_on_circle" title="Link to this definition"></a></dt>
<dd><p>Generate <cite>num</cite> points on a circle given its center and radius.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>center</strong> (<em>list</em><em> or </em><em>array-like</em>) – Coordinates of the circle’s center</p></li>
<li><p><strong>radius</strong> (<em>float</em>) – Radius of the circle</p></li>
<li><p><strong>plane</strong> (<em>list</em><em> or </em><em>array-like</em>) – Plane coefficient <code class="docutils literal notranslate"><span class="pre">[a,</span> <span class="pre">b,</span> <span class="pre">c,</span> <span class="pre">d]</span></code> which the circle lies on.
For 2D, this term is neglectable.</p></li>
<li><p><strong>num</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of points to generate on the circle, default is 50</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Array of points lying on the circle</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.ndarray</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>AssertionError</strong> – If the dimensions of center, radius, or plane are incorrect.</p></li>
<li><p><strong>AssertionError</strong> – If got negative radius</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geometric.circle_coordinate_transform">
<span class="sig-prename descclassname"><span class="pre">geometric.</span></span><span class="sig-name descname"><span class="pre">circle_coordinate_transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">center</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plane</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x_direction_point</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#geometric.circle_coordinate_transform" title="Link to this definition"></a></dt>
<dd><p>Calculate the transformation matrix from a new coordinate system to the original one. The transformed circle is
centered at origin and lies in XY plane (<span class="math notranslate nohighlight">\(Z=0\)</span>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>center</strong> (<em>list</em><em> or </em><em>array-like</em>) – Coordinates of the circle’s center</p></li>
<li><p><strong>plane</strong> (<em>list</em><em> or </em><em>array-like</em>) – Plane coefficient <code class="docutils literal notranslate"><span class="pre">[a,</span> <span class="pre">b,</span> <span class="pre">c,</span> <span class="pre">d]</span></code> which the circle lies in</p></li>
<li><p><strong>x_direction_point</strong> (<em>list</em><em> or </em><em>array-like</em><em> or </em><em>None</em>) – Point in the plane to determine the x-axis direction.
If not provided, a random point on the plane is chosen.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Transformation matrix T of shape (4, 4) that transforms coordinates into the original coordinate system</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.ndarray</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>AssertionError</strong> – If the dimensions of center or plane are incorrect</p></li>
<li><p><strong>AssertionError</strong> – If <cite>x_direction_point</cite> is provided but its dimensions are not 3.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</section>
<section id="arc">
<h2>Arc<a class="headerlink" href="#arc" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="geometric.arc_from_center_and_endpoints">
<span class="sig-prename descclassname"><span class="pre">geometric.</span></span><span class="sig-name descname"><span class="pre">arc_from_center_and_endpoints</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">center</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#geometric.arc_from_center_and_endpoints" title="Link to this definition"></a></dt>
<dd><p>Compute the parameters of an arc defined by its center and endpoints.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>center</strong> (<em>list</em><em> or </em><em>array-like</em>) – Center coordinates of the arc</p></li>
<li><p><strong>p1</strong> (<em>list</em><em> or </em><em>array-like</em>) – First endpoint coordinates of the arc</p></li>
<li><p><strong>p2</strong> (<em>list</em><em> or </em><em>array-like</em>) – Second endpoint coordinates of the arc</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p>A tuple containing:</p>
<ul>
<li><p>numpy.ndarray: Center of the arc</p></li>
<li><p>float: Radius of the arc</p></li>
<li><p>list: angle range of the arc</p>
<blockquote>
<div><ul class="simple">
<li><p>2D: angle is relative to X-axis</p></li>
<li><p>3D: angle is relative to the direction of <cite>center</cite> to <cite>p1</cite></p></li>
</ul>
</div></blockquote>
</li>
<li><p>numpy.ndarray: transformation matrix to convert arc coordinates.</p>
<blockquote>
<div><ul class="simple">
<li><p>2D: the matrix is with shape 3x3</p></li>
<li><p>3D: the matrix is with shape 4x4</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>AssertionError</strong> – If the dimensions of center, p1, or p2 are not consistent</p></li>
<li><p><strong>AssertionError</strong> – If the dimension of the point is not 2 nor 3</p></li>
<li><p><strong>AssertionError</strong> – If the distances from the center to p1 and p2 are not equal within a tolerance.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geometric.arc_from_three_points">
<span class="sig-prename descclassname"><span class="pre">geometric.</span></span><span class="sig-name descname"><span class="pre">arc_from_three_points</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p3</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#geometric.arc_from_three_points" title="Link to this definition"></a></dt>
<dd><p>Construct an arc passing through three points in 2D or 3D space.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>p1</strong> (<em>list</em><em> or </em><em>array-like</em>) – First point on the arc.</p></li>
<li><p><strong>p2</strong> (<em>list</em><em> or </em><em>array-like</em>) – Second point on the arc.</p></li>
<li><p><strong>p3</strong> (<em>list</em><em> or </em><em>array-like</em>) – Third point on the arc.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p>A tuple containing:</p>
<ul>
<li><p>numpy.ndarray: Center of the arc</p></li>
<li><p>float: Radius of the arc</p></li>
<li><p>list: angle range of the arc</p>
<blockquote>
<div><ul class="simple">
<li><p>2D: angle is relative to X-axis</p></li>
<li><p>3D: angle is relative to the direction of <cite>center</cite> to <cite>p1</cite></p></li>
</ul>
</div></blockquote>
</li>
<li><p>numpy.ndarray: transformation matrix to convert arc coordinates.</p>
<blockquote>
<div><ul class="simple">
<li><p>2D: the matrix is with shape 3x3</p></li>
<li><p>3D: the matrix is with shape 4x4</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>AssertionError</strong> – If input point dimensions are invalid or inconsistent.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geometric.generate_points_on_arc">
<span class="sig-prename descclassname"><span class="pre">geometric.</span></span><span class="sig-name descname"><span class="pre">generate_points_on_arc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">center</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radius</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta_range</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">transform</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#geometric.generate_points_on_arc" title="Link to this definition"></a></dt>
<dd><p>Generate <cite>num</cite> points on an arc given its center, radius, range of theta and the transform.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>center</strong> (<em>numpy.ndarray</em>) – Center of the arc</p></li>
<li><p><strong>radius</strong> (<em>float</em>) – Radius of the arc</p></li>
<li><p><strong>thetas</strong> (<em>list</em>) – <p>Angle range of the arc</p>
<ul>
<li><p>2D: angle is relative to X-axis</p></li>
<li><p>3D: angle is relative to X-axis in new coordinate</p></li>
</ul>
</p></li>
<li><p><strong>T</strong> (<em>numpy.ndarray</em>) – <p>Transformation matrix to convert arc coordinates into original coordinate</p>
<ul>
<li><p>2D: the matrix is with shape 3x3</p></li>
<li><p>3D: the matrix is with shape 4x4</p></li>
</ul>
</p></li>
<li><p><strong>num</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of points to generate on the circle, default is 50</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Array of points lying on the arc</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.ndarray</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>AssertionError</strong> – If the dimensions of center is incorrect</p></li>
<li><p><strong>AssertionError</strong> – If got negative radius</p></li>
<li><p><strong>AssertionError</strong> – If the dimension of center is mismatched withe the transform</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geometric.is_point_on_arc">
<span class="sig-prename descclassname"><span class="pre">geometric.</span></span><span class="sig-name descname"><span class="pre">is_point_on_arc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arc</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#geometric.is_point_on_arc" title="Link to this definition"></a></dt>
<dd><p>Determines if a point lies on a given arc.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> (<em>list</em><em> or </em><em>array-like</em>) – Coordinates of the point to check</p></li>
<li><p><strong>arc</strong> (<em>tuple</em>) – <p>A tuple contains center, radius, theta_range, and transform.</p>
<ul>
<li><p>center (numpy.ndarray): Center of the arc</p></li>
<li><p>radius (float): Radius of the arc</p></li>
<li><p>thetas (list): Angle range of the arc</p>
<blockquote>
<div><ul class="simple">
<li><p>2D: angle is relative to X-axis</p></li>
<li><p>3D: angle is relative to the direction of <cite>center</cite> to <cite>p1</cite></p></li>
</ul>
</div></blockquote>
</li>
<li><p>T (numpy.ndarray): Transformation matrix to convert arc coordinates.</p>
<blockquote>
<div><ul class="simple">
<li><p>2D: the matrix is with shape 3x3</p></li>
<li><p>3D: the matrix is with shape 4x4</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>True if the point is on the arc, False otherwise</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>AssertionError</strong> – If the dimensions of the inputs are not consistent.</p></li>
<li><p><strong>AssertionError</strong> – If the length of arc is incorrect</p></li>
<li><p><strong>AssertionError</strong> – If the radius is negative</p></li>
</ul>
</dd>
</dl>
<div class="admonition-todo admonition" id="id2">
<p class="admonition-title">Todo</p>
<p>3D is not supported yet!</p>
</div>
</dd></dl>

</section>
<section id="sphere">
<h2>Sphere<a class="headerlink" href="#sphere" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="geometric.distance_between_points_on_sphere">
<span class="sig-prename descclassname"><span class="pre">geometric.</span></span><span class="sig-name descname"><span class="pre">distance_between_points_on_sphere</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sphere</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#geometric.distance_between_points_on_sphere" title="Link to this definition"></a></dt>
<dd><p>Calculate the shortest distance (i.e., geodesic) between two points on the surface of a sphere.</p>
<p>The function assumes that both points lie exactly on the surface of the sphere.
The distance is computed as the product of the sphere’s radius and the angle (in radians)
between the vectors from the sphere center to each point.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>p1</strong> (<em>list</em><em> or </em><em>array-like</em>) – Coordinates of the first point on the sphere surface.</p></li>
<li><p><strong>p2</strong> (<em>list</em><em> or </em><em>array-like</em>) – Coordinates of the second point on the sphere surface.</p></li>
<li><p><strong>sphere</strong> (<em>tuple</em>) – <p>A tuple (center, radius), where:</p>
<ul>
<li><p>center (list or array-like): Coordinates of the sphere’s center.</p></li>
<li><p>radius (float): Radius of the sphere (must be positive).</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The great-circle distance between the two points along the sphere’s surface.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>AssertionError</strong> – If inputs are not valid 3D points</p></li>
<li><p><strong>AssertionError</strong> – If radius is non-positive</p></li>
<li><p><strong>AssertionError</strong> – If points are not on the sphere surface</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geometric.random_point_on_sphere">
<span class="sig-prename descclassname"><span class="pre">geometric.</span></span><span class="sig-name descname"><span class="pre">random_point_on_sphere</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sphere</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#geometric.random_point_on_sphere" title="Link to this definition"></a></dt>
<dd><p>Generate a random point uniformly distributed on the surface of a sphere.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>sphere</strong> (<em>tuple</em>) – <p>A tuple (center, radius), where:</p>
<ul class="simple">
<li><p>center (list or array-like): Coordinates of the sphere’s center (3D).</p></li>
<li><p>radius (float): Radius of the sphere (must be positive).</p></li>
</ul>
</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A 3D coordinate of the random point on the sphere surface.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.ndarray</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>AssertionError</strong> – If the input is not a valid sphere definition.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geometric.spherical_cap_volume">
<span class="sig-prename descclassname"><span class="pre">geometric.</span></span><span class="sig-name descname"><span class="pre">spherical_cap_volume</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">radius</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">height</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#geometric.spherical_cap_volume" title="Link to this definition"></a></dt>
<dd><p>Calculate the volume of a spherical cap.</p>
<p>A spherical cap is the portion of a sphere cut off by a plane. The formula used is:
<span class="math notranslate nohighlight">\(V = \frac{\pi h^2 (3R - h)}{3}\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>radius</strong> (<em>float</em>) – Radius of the sphere (must be positive).</p></li>
<li><p><strong>height</strong> (<em>float</em>) – Height of the cap (must be in [0, 2 * radius)).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Volume of the spherical cap.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>AssertionError</strong> – If the radius is not positive, height is negative, or exceeds the sphere’s diameter.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geometric.overlap_volume_between_spheres">
<span class="sig-prename descclassname"><span class="pre">geometric.</span></span><span class="sig-name descname"><span class="pre">overlap_volume_between_spheres</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sphere1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sphere2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#geometric.overlap_volume_between_spheres" title="Link to this definition"></a></dt>
<dd><p>Compute the volume of intersection (overlap) between two spheres.</p>
<p>The overlap volume is calculated using the analytical formula for intersecting spheres
based on the distance between centers and their respective radii.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sphere1</strong> (<em>tuple</em>) – <p>A tuple (center, radius), where:</p>
<ul>
<li><p>center (list or array-like): Coordinates of the first sphere center.</p></li>
<li><p>radius (float): Radius of the first sphere (must be positive).</p></li>
</ul>
</p></li>
<li><p><strong>sphere2</strong> (<em>tuple</em>) – Same format as <cite>sphere1</cite>, representing the second sphere.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Volume of the overlapping region. Returns 0 if spheres do not intersect.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>AssertionError</strong> – If sphere definitions are invalid or contain non-positive radii.</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="parameters-from-noisy-data">
<h2>Parameters from Noisy Data<a class="headerlink" href="#parameters-from-noisy-data" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="geometric.line_from_noisy_data">
<span class="sig-prename descclassname"><span class="pre">geometric.</span></span><span class="sig-name descname"><span class="pre">line_from_noisy_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">points</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#geometric.line_from_noisy_data" title="Link to this definition"></a></dt>
<dd><p>Estimate the best-fit line from noisy points in 2D or 3D space.</p>
<ul class="simple">
<li><p>In <strong>2D</strong>, the line is fitted using least squares to minimize vertical error from the model <span class="math notranslate nohighlight">\(y = ax + b\)</span>.
The result is returned in the form of normalized coefficients [a, b, c] for the line equation
<span class="math notranslate nohighlight">\(ax + by + c = 0\)</span> where <span class="math notranslate nohighlight">\(\sqrt{a^2+b^2}=1\)</span>.</p></li>
<li><p>In <strong>3D</strong>, the line is estimated by performing PCA (Principal Component Analysis) on the points to find
the main direction of variance.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>points</strong> (<em>array-like</em>) – A list or array of shape <code class="docutils literal notranslate"><span class="pre">(N,</span> <span class="pre">2)</span></code> or <code class="docutils literal notranslate"><span class="pre">(N,</span> <span class="pre">3)</span></code>, containing at least two points.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>In 2D: Normalized line coefficients <code class="docutils literal notranslate"><span class="pre">[a,</span> <span class="pre">b,</span> <span class="pre">c]</span></code>.</p></li>
<li><p>In 3D: A list [point, direction_vector], where both elements are lists of 3 floats.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>AssertionError</strong> – If the input does not have 2D or 3D shape.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geometric.plane_from_noisy_data">
<span class="sig-prename descclassname"><span class="pre">geometric.</span></span><span class="sig-name descname"><span class="pre">plane_from_noisy_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">points</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#geometric.plane_from_noisy_data" title="Link to this definition"></a></dt>
<dd><p>Estimate the best-fitting plane from a set of noisy 3D points using least squares method.</p>
<p>The plane is estimated in the form: <span class="math notranslate nohighlight">\(ax + by + cz + d = 0\)</span>, with <span class="math notranslate nohighlight">\(\sqrt{a^2 + b^2 + c^2} = 1\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>points</strong> (<em>array-like</em>) – A list or array of shape <code class="docutils literal notranslate"><span class="pre">(N,</span> <span class="pre">3)</span></code>, where N &gt; 3, containing 3D points.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Normalized plane coefficients <code class="docutils literal notranslate"><span class="pre">[a,</span> <span class="pre">b,</span> <span class="pre">c,</span> <span class="pre">d]</span></code> such that <span class="math notranslate nohighlight">\(ax + by + cz + d = 0\)</span>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>AssertionError</strong> – If the input does not contain at least 4 points or if points are not 3D.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geometric.circle_from_noisy_data">
<span class="sig-prename descclassname"><span class="pre">geometric.</span></span><span class="sig-name descname"><span class="pre">circle_from_noisy_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#geometric.circle_from_noisy_data" title="Link to this definition"></a></dt>
<dd><p>Calculate the circle given by noised data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>data</strong> (<em>list</em><em> or </em><em>array-like</em>) – sampled noised data, should with shape either <code class="docutils literal notranslate"><span class="pre">(N,</span> <span class="pre">2)</span></code> or <code class="docutils literal notranslate"><span class="pre">(N,</span> <span class="pre">3)</span></code>.
N should greater than or equal to 4.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>center (numpy.ndarray): coordinates of the circle’s center</p></li>
<li><p>radius (float): radius of the circle</p></li>
<li><p>plane (list):
plane coefficient <code class="docutils literal notranslate"><span class="pre">[a,</span> <span class="pre">b,</span> <span class="pre">c,</span> <span class="pre">d]</span></code> which the circle lies on.
For 2D, this term is neglectable and XY plane is returned</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>AssertionError</strong> – if N less then 4</p></li>
<li><p><strong>AssertionError</strong> – if the dimension of the point is not 2 nor 3</p></li>
</ul>
</dd>
</dl>
<div class="admonition-todo admonition" id="id3">
<p class="admonition-title">Todo</p>
<p>3D is not supported yet!</p>
</div>
</dd></dl>

</section>
<section id="relation-between-point-and-shape">
<h2>Relation between Point and Shape<a class="headerlink" href="#relation-between-point-and-shape" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="geometric.point_triangle_relation">
<span class="sig-prename descclassname"><span class="pre">geometric.</span></span><span class="sig-name descname"><span class="pre">point_triangle_relation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p3</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#geometric.point_triangle_relation" title="Link to this definition"></a></dt>
<dd><p>Determine the relation between <cite>p</cite> and the triangle formed by <cite>p1</cite>, <cite>p2</cite> and <cite>p3</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>p</strong> (<em>list</em><em> or </em><em>array-like</em>) – Coordinates of the point to check</p></li>
<li><p><strong>p1</strong> (<em>list</em><em> or </em><em>array-like</em>) – Coordinates of the first vertex of the triangle</p></li>
<li><p><strong>p2</strong> (<em>list</em><em> or </em><em>array-like</em>) – Coordinates of the second vertex of the triangle</p></li>
<li><p><strong>p3</strong> (<em>list</em><em> or </em><em>array-like</em>) – Coordinates of the third vertex of the triangle</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p>Enumeration as following</p>
<ul class="simple">
<li><p>0: If point is inside the triangle</p></li>
<li><p>1: If point in on the border of the triangle</p></li>
<li><p>2: If point is outside the triangle</p></li>
<li><p>3: If point is not in the plane formed by three vertices (3D only)</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>PointTriangleEnum</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>AssertionError</strong> – If the dimensions of the points are not consistent.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geometric.point_cylinder_relation">
<span class="sig-prename descclassname"><span class="pre">geometric.</span></span><span class="sig-name descname"><span class="pre">point_cylinder_relation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cylinder</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#geometric.point_cylinder_relation" title="Link to this definition"></a></dt>
<dd><p>Determine the spatial relationship between a point and a cylinder.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>p</strong> (<em>list</em><em> or </em><em>array-like</em>) – Coordinates of the 3D point to be tested.</p></li>
<li><p><strong>cylinder</strong> (<em>tuple</em>) – <p>A tuple (bottom_center, radius, height, direction), where:</p>
<ul>
<li><p>bottom_center (list or array-like): The 3D coordinates of the cylinder’s base center.</p></li>
<li><p>radius (float): Radius of the cylinder (must be positive).</p></li>
<li><p>height (float): Height of the cylinder (must be positive).</p></li>
<li><p>direction (list or array-like): A 3D vector indicating the axis direction.</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p>Enumeratiion as following:</p>
<ul class="simple">
<li><p>0: If point is inside the cylinder</p></li>
<li><p>1: If point is on the border of the cylinder</p></li>
<li><p>2: If point is out of the cylinder</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>PointShapeEnum</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>AssertionError</strong> – If the cylinder parameters are invalid or improperly formatted.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geometric.point_sphere_relation">
<span class="sig-prename descclassname"><span class="pre">geometric.</span></span><span class="sig-name descname"><span class="pre">point_sphere_relation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sphere</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#geometric.point_sphere_relation" title="Link to this definition"></a></dt>
<dd><p>Determine the spatial relationship between a point and a sphere.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> (<em>list</em><em> or </em><em>array-like</em>) – 3D coordinates of the point to be tested.</p></li>
<li><p><strong>sphere</strong> (<em>tuple</em>) – <p>A tuple (center, radius), where:</p>
<ul>
<li><p>center (list or array-like): 3D coordinates of the sphere’s center.</p></li>
<li><p>radius (float): Radius of the sphere (must be positive).</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p>Enumeration as following</p>
<blockquote>
<div><ul class="simple">
<li><p>0: If point is inside the cylinder</p></li>
<li><p>1: If point is on the border of the cylinder</p></li>
<li><p>2: If point is out of the cylinder</p></li>
</ul>
</div></blockquote>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>PointShapeEnum</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>AssertionError</strong> – If the input point or sphere is invalid or improperly formatted.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geometric.point_circle_relation">
<span class="sig-prename descclassname"><span class="pre">geometric.</span></span><span class="sig-name descname"><span class="pre">point_circle_relation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">circle</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#geometric.point_circle_relation" title="Link to this definition"></a></dt>
<dd><p>Get relation between a point and a circle.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> (<em>list</em><em> or </em><em>array-like</em>) – Point coordinates to check.</p></li>
<li><p><strong>circle</strong> (<em>tuple</em>) – <ul>
<li><p>center (list or array-like): Coordinates of the circle’s center</p></li>
<li><p>radius (float): Radius of the circle</p></li>
<li><dl class="simple">
<dt>plane (list or array-like):</dt><dd><p>Plane coefficient <code class="docutils literal notranslate"><span class="pre">[a,</span> <span class="pre">b,</span> <span class="pre">c,</span> <span class="pre">d]</span></code> which the circle lies on.
For 2D, this term is neglectable.</p>
</dd>
</dl>
</li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p>True if the point lies on the circle, False otherwise
PointCircleEnum: Enumeration as following:</p>
<ul class="simple">
<li><p>0: If the point is inside the circle</p></li>
<li><p>1: If the point is on the border of the circle</p></li>
<li><p>2: If the point is outside the circle</p></li>
<li><p>3: If the point is not on the plane of the circle (3D only)</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>AssertionError</strong> – if the dimensions of center, radius, or plane (only in 3D) are incorrect.</p></li>
<li><p><strong>AssertionError</strong> – if got negative radius</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</section>
<section id="transform-between-coordinates">
<h2>Transform between Coordinates<a class="headerlink" href="#transform-between-coordinates" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="geometric.cartesian_to_spherical">
<span class="sig-prename descclassname"><span class="pre">geometric.</span></span><span class="sig-name descname"><span class="pre">cartesian_to_spherical</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#geometric.cartesian_to_spherical" title="Link to this definition"></a></dt>
<dd><p>Convert a 3D point from Cartesian coordinates to spherical coordinates.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>point</strong> (<em>list</em><em> or </em><em>array-like</em>) – A 3D point <code class="docutils literal notranslate"><span class="pre">[x,</span> <span class="pre">y,</span> <span class="pre">z]</span></code>.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p>A 3-element array <code class="docutils literal notranslate"><span class="pre">[radius,</span> <span class="pre">theta,</span> <span class="pre">phi]</span></code> where</p>
<ul class="simple">
<li><p>radius: Distance from the origin to the point (must be non-zero).</p></li>
<li><p>theta (azimuth): Angle in the XY plane from the X-axis, in radians <span class="math notranslate nohighlight">\([0, 2\pi)\)</span>.</p></li>
<li><p>phi (zenith): Angle from the positive Z-axis, in radians <span class="math notranslate nohighlight">\([0, \pi]\)</span>.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.ndarray</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>AssertionError</strong> – If the input point is not 3D or the radius is zero.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geometric.spherical_to_cartesian">
<span class="sig-prename descclassname"><span class="pre">geometric.</span></span><span class="sig-name descname"><span class="pre">spherical_to_cartesian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#geometric.spherical_to_cartesian" title="Link to this definition"></a></dt>
<dd><p>Convert a 3D point from spherical coordinates to Cartesian coordinates.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>point</strong> (<em>list</em><em> or </em><em>array-like</em>) – A 3-element list or array <code class="docutils literal notranslate"><span class="pre">[radius,</span> <span class="pre">theta,</span> <span class="pre">phi]</span></code>.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A 3D point <code class="docutils literal notranslate"><span class="pre">[x,</span> <span class="pre">y,</span> <span class="pre">z]</span></code> in Cartesian coordinates.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.ndarray</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>AssertionError</strong> – If the input is not valid spherical coordinates.</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="pose">
<h2>Pose<a class="headerlink" href="#pose" title="Link to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="geometric.Pose">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">geometric.</span></span><span class="sig-name descname"><span class="pre">Pose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">trans</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rot</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#geometric.Pose" title="Link to this definition"></a></dt>
<dd><p>Represents a 3D pose composed of a translation and a rotation, stored as a 4x4 transformation matrix.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="geometric.Pose.matrix">
<span class="sig-name descname"><span class="pre">matrix</span></span><a class="headerlink" href="#geometric.Pose.matrix" title="Link to this definition"></a></dt>
<dd><p>The 4x4 transformation matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>nump.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="geometric.Pose.translation">
<span class="sig-name descname"><span class="pre">translation</span></span><a class="headerlink" href="#geometric.Pose.translation" title="Link to this definition"></a></dt>
<dd><p>The 3D translation vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>nump.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="geometric.Pose.rotation">
<span class="sig-name descname"><span class="pre">rotation</span></span><a class="headerlink" href="#geometric.Pose.rotation" title="Link to this definition"></a></dt>
<dd><p>The rotation represented as a rotation vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="geometric.Pose.inv">
<span class="sig-name descname"><span class="pre">inv</span></span><a class="headerlink" href="#geometric.Pose.inv" title="Link to this definition"></a></dt>
<dd><p>The inverse of the pose.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#geometric.Pose" title="geometric.Pose">Pose</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="geometric.Pose.chain">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">chain</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">poses</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#geometric.Pose.chain" title="Link to this definition"></a></dt>
<dd><p>Chains multiple Pose instances via left-to-right multiplication.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>*poses</strong> (<a class="reference internal" href="#geometric.Pose" title="geometric.Pose"><em>Pose</em></a>) – Any number of Pose instances.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The resulting Pose from multiplying all inputs.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#geometric.Pose" title="geometric.Pose">Pose</a></p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>AssertionError</strong> – If any input is not a Pose.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="geometric.Pose.diff">
<span class="sig-name descname"><span class="pre">diff</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rhs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#geometric.Pose.diff" title="Link to this definition"></a></dt>
<dd><p>Computes the difference transformation between self and rhs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>rhs</strong> (<a class="reference internal" href="#geometric.Pose" title="geometric.Pose"><em>Pose</em></a>) – The target pose.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The relative transformation Pose</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#geometric.Pose" title="geometric.Pose">Pose</a></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">self</span> <span class="pre">*</span> <span class="pre">diff</span> <span class="pre">=</span> <span class="pre">rhs</span></code></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="geometric.Pose.distance">
<span class="sig-name descname"><span class="pre">distance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ref_point</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">array([0.,</span> <span class="pre">0.,</span> <span class="pre">0.])</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#geometric.Pose.distance" title="Link to this definition"></a></dt>
<dd><p>Compute the Euclidean distance from this pose’s translation to a given reference point.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ref_point</strong> (<em>array-like</em><em>, </em><em>optional</em>) – A 3D reference point. Defaults to <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">0,</span> <span class="pre">0]</span></code>.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The distance from the <cite>ref_point</cite> to this pose’s translation.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>AssertionError</strong> – If the point is not with length 3</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="geometric.Pose.from_matrix">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matrix</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#geometric.Pose.from_matrix" title="Link to this definition"></a></dt>
<dd><p>Creates a Pose instance from a 4x4 transformation matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>matrix</strong> (<em>np.ndarray</em>) – A 4x4 homogeneous transformation matrix.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A new Pose instance.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#geometric.Pose" title="geometric.Pose">Pose</a></p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>AssertionError</strong> – If matrix is not valid.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="geometric.Pose.from_ros_geometry_pose">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_ros_geometry_pose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pose</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#geometric.Pose.from_ros_geometry_pose" title="Link to this definition"></a></dt>
<dd><p>Converts a ROS <a class="reference external" href="https://docs.ros.org/en/noetic/api/geometry_msgs/html/msg/Pose.html">geometry_msgs/Pose</a>
message to a Pose.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>pose</strong> – A geometry_msgs/Pose object.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A new Pose instance.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#geometric.Pose" title="geometric.Pose">Pose</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="geometric.Pose.from_ros_geometry_pose_stamped">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_ros_geometry_pose_stamped</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pose</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#geometric.Pose.from_ros_geometry_pose_stamped" title="Link to this definition"></a></dt>
<dd><p>Converts a ROS <a class="reference external" href="https://docs.ros.org/en/noetic/api/geometry_msgs/html/msg/PoseStamped.html">geometry_msgs/PoseStamped</a> message to a Pose.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>pose</strong> – A geometry_msgs/PoseStamped object.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A new Pose instance.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#geometric.Pose" title="geometric.Pose">Pose</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="geometric.Pose.get_axis_angle">
<span class="sig-name descname"><span class="pre">get_axis_angle</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#geometric.Pose.get_axis_angle" title="Link to this definition"></a></dt>
<dd><p>Get the axis-angle representation of the pose’s orientation.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><p>A tuple (axis, angle), where:</p>
<blockquote>
<div><ul class="simple">
<li><p>axis (numpy.ndarray): A 3D unit vector representing the rotation axis.</p></li>
<li><p>angle (float): Rotation angle in radians.</p></li>
</ul>
</div></blockquote>
</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="geometric.Pose.get_euler">
<span class="sig-name descname"><span class="pre">get_euler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sequence</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#geometric.Pose.get_euler" title="Link to this definition"></a></dt>
<dd><p>Get the Euler angles of the pose’s orientation in the specified rotation sequence.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>sequence</strong> (<em>str</em>) – A 3-character string indicating the rotation axes order (e.g., <code class="docutils literal notranslate"><span class="pre">xyz</span></code>).</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A 3-element array of Euler angles (in radians).</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.ndarray</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>AssertionError</strong> – If the sequence format is invalid.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>See sequence definition from <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.transform.Rotation.from_euler.html#scipy.spatial.transform.Rotation.from_euler">scipy</a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="geometric.Pose.get_quaternion">
<span class="sig-name descname"><span class="pre">get_quaternion</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#geometric.Pose.get_quaternion" title="Link to this definition"></a></dt>
<dd><p>Get the quaternion representation of the pose’s orientation.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A 4-element quaternion in <code class="docutils literal notranslate"><span class="pre">[x,</span> <span class="pre">y,</span> <span class="pre">z,</span> <span class="pre">w]</span></code> format.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>numpy.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="geometric.Pose.get_rotvec">
<span class="sig-name descname"><span class="pre">get_rotvec</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#geometric.Pose.get_rotvec" title="Link to this definition"></a></dt>
<dd><p>Get the rotation vector (Rodrigues vector) representation of the pose’s orientation.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A 3-element rotation vector.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>numpy.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="geometric.Pose.identity">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">identity</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#geometric.Pose.identity" title="Link to this definition"></a></dt>
<dd><p>Returns the identity Pose.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A Pose representing the identity transformation.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#geometric.Pose" title="geometric.Pose">Pose</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="geometric.Pose.interpolate">
<span class="sig-name descname"><span class="pre">interpolate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">target_pose</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#geometric.Pose.interpolate" title="Link to this definition"></a></dt>
<dd><p>Interpolates between self and a target pose.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>target_pose</strong> (<a class="reference internal" href="#geometric.Pose" title="geometric.Pose"><em>Pose</em></a>) – The target pose.</p></li>
<li><p><strong>num</strong> (<em>int</em>) – Number of interpolation steps, <strong>including</strong> the start and end poses. Must greater than 2.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A list of interpolated Pose instances.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list of <a class="reference internal" href="#geometric.Pose" title="geometric.Pose">Pose</a></p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>AssertionError</strong> – If <cite>target_pose</cite> is not a Pose.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>num</cite> less than 3.</p></li>
</ul>
</dd>
</dl>
<p>The translation is interpolated linearly, while the rotation is interpolated using spherical
linear interpolation (SLERP).</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">geometric</span> <span class="kn">import</span> <span class="n">Pose</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p1</span> <span class="o">=</span> <span class="n">Pose</span><span class="o">.</span><span class="n">identity</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p2</span> <span class="o">=</span> <span class="n">Pose</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="mi">120</span><span class="p">)]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ps</span> <span class="o">=</span> <span class="n">p1</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">p2</span><span class="p">,</span> <span class="mi">11</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">([</span><span class="n">p</span><span class="o">.</span><span class="n">translation</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">ps</span><span class="p">])</span>
<span class="go">[0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0]</span>
</pre></div>
</div>
<p>Visualization with <a class="reference external" href="https://www.open3d.org/docs/release/">Open3d</a></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">open3d</span> <span class="k">as</span> <span class="nn">o3d</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">geoms</span> <span class="o">=</span> <span class="p">[</span><span class="n">o3d</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">TriangleMesh</span><span class="o">.</span><span class="n">create_coordinate_frame</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">matrix</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">ps</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">o3d</span><span class="o">.</span><span class="n">visualization</span><span class="o">.</span><span class="n">draw_geometries</span><span class="p">(</span><span class="n">geoms</span><span class="p">)</span>
</pre></div>
</div>
<p>Result</p>
<figure class="align-center">
<img alt="_images/interpolate.png" src="_images/interpolate.png" />
</figure>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="geometric.Pose.random_pose">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">random_pose</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#geometric.Pose.random_pose" title="Link to this definition"></a></dt>
<dd><p>Generates a random Pose with translation in [0, 1] and rotation up to <span class="math notranslate nohighlight">\(\pi\)</span> radians.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A randomly generated Pose.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#geometric.Pose" title="geometric.Pose">Pose</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="geometric.Pose.set_rotation_from_axis_angle">
<span class="sig-name descname"><span class="pre">set_rotation_from_axis_angle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">axis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">angle</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#geometric.Pose.set_rotation_from_axis_angle" title="Link to this definition"></a></dt>
<dd><p>Sets the rotation from an axis and angle.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>axis</strong> (<em>array-like</em>) – A 3-element rotation axis.</p></li>
<li><p><strong>angle</strong> (<em>float</em>) – The rotation angle in radians.</p></li>
</ul>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>AssertionError</strong> – If axis is not of length 3 or angle is not a float.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="geometric.Pose.set_rotation_from_euler">
<span class="sig-name descname"><span class="pre">set_rotation_from_euler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">angles</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sequence</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#geometric.Pose.set_rotation_from_euler" title="Link to this definition"></a></dt>
<dd><p>Sets the rotation from Euler angles.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>angles</strong> (<em>array-like</em>) – A 3-element list of Euler angles.</p></li>
<li><p><strong>sequence</strong> (<em>str</em>) – A valid 3-character rotation sequence (e.g., <code class="docutils literal notranslate"><span class="pre">xyz</span></code>).</p></li>
</ul>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>AssertionError</strong> – If input is invalid.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>See sequence definition from <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.transform.Rotation.from_euler.html#scipy.spatial.transform.Rotation.from_euler">scipy</a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="geometric.Pose.set_rotation_from_matrix">
<span class="sig-name descname"><span class="pre">set_rotation_from_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rot</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#geometric.Pose.set_rotation_from_matrix" title="Link to this definition"></a></dt>
<dd><p>Sets the rotation from a 3x3 rotation matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>rot</strong> (<em>array-like</em>) – A 3x3 rotation matrix.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>AssertionError</strong> – If input is not a valid 3x3 matrix.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="geometric.Pose.set_rotation_from_quaternion">
<span class="sig-name descname"><span class="pre">set_rotation_from_quaternion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">quat</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#geometric.Pose.set_rotation_from_quaternion" title="Link to this definition"></a></dt>
<dd><p>Sets the rotation from a quaternion.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>quat</strong> (<em>array-like</em>) – A 4-element quaternion <code class="docutils literal notranslate"><span class="pre">[x,</span> <span class="pre">y,</span> <span class="pre">z,</span> <span class="pre">w]</span></code>.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>AssertionError</strong> – If input quaternion is not of length 4.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="geometric.Pose.set_rotation_from_rotvec">
<span class="sig-name descname"><span class="pre">set_rotation_from_rotvec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rv</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#geometric.Pose.set_rotation_from_rotvec" title="Link to this definition"></a></dt>
<dd><p>Sets the rotation from a rotation vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>rv</strong> (<em>array-like</em>) – A 3-element rotation vector.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>AssertionError</strong> – If input vector is not of length 3.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="geometric.Pose.set_rotation_from_vector">
<span class="sig-name descname"><span class="pre">set_rotation_from_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vector</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#geometric.Pose.set_rotation_from_vector" title="Link to this definition"></a></dt>
<dd><p>Set the rotation such that the reference axis is rotated to align with the given vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vector</strong> (<em>list</em><em> or </em><em>array-like</em>) – The target 3D direction vector to align with.</p></li>
<li><p><strong>target_axis</strong> (<em>int</em><em>, </em><em>optional</em>) – The index of the original axis to align (0: X, 1: Y, 2: Z). Defaults to 2.</p></li>
</ul>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>AssertionError</strong> – If the axis index is not between 0 and 2 (inclusive).</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="geometric.Pose.set_translation">
<span class="sig-name descname"><span class="pre">set_translation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">trans</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#geometric.Pose.set_translation" title="Link to this definition"></a></dt>
<dd><p>Sets the translation component of the pose.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>trans</strong> (<em>array-like</em>) – A 3-element translation vector.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>AssertionError</strong> – If input vector is not of length 3.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="geometric.Pose.transform_point">
<span class="sig-name descname"><span class="pre">transform_point</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#geometric.Pose.transform_point" title="Link to this definition"></a></dt>
<dd><p>Apply the pose transformation to a single 3D point.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>point</strong> (<em>array-like</em>) – A 3D point to transform.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The transformed 3D point.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.ndarray</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>AssertionError</strong> – If the point is not with length 3</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="geometric.Pose.transform_points">
<span class="sig-name descname"><span class="pre">transform_points</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">points</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#geometric.Pose.transform_points" title="Link to this definition"></a></dt>
<dd><p>Apply the pose transformation to a list or array of 3D points.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>points</strong> (<em>array-like</em>) – A <code class="docutils literal notranslate"><span class="pre">(N,</span> <span class="pre">3)</span></code> array of 3D points.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The transformed points, shape <code class="docutils literal notranslate"><span class="pre">(N,</span> <span class="pre">3)</span></code>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.ndarray</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>AssertionError</strong> – If input does not have shape <code class="docutils literal notranslate"><span class="pre">(N,</span> <span class="pre">3)</span></code>.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="Representation.html" class="btn btn-neutral float-left" title="Representation" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, SEAN.LU.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>